<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>p5 + 3D Force Graph (hover image)</title>

  <link rel="stylesheet" type="text/css" href="style.css">

  <script src="libraries/p5.min.js"></script>
  <script src="libraries/p5.sound.min.js"></script>
  <style>
    body {
      margin: 0;
    }
  </style>

  <script src="//cdn.jsdelivr.net/npm/3d-force-graph"></script>
  <!--<script src="../../dist/3d-force-graph.js"></script>-->
</head>


<body>
  <script src="sketch.js"></script>
  <div id="3d-graph"></div>

  <script type="module">
  import * as THREE from 'https://esm.sh/three';

  // 1. start 3D Force Graph
  const Graph = new ForceGraph3D(document.getElementById('3d-graph'))
    .linkWidth(0.2)
    .linkColor(() => '#ffffff')
    .linkOpacity(0.6)
    .nodeThreeObject(node => {
      // if node.img is not a full URL, prepend the S3 bucket URL
      const loader = new THREE.TextureLoader();
      // set crossOrigin to anonymous to avoid CORS issues
      loader.setCrossOrigin('anonymous');

      const texture = loader.load(node.img, tex => { // node.img is expected to be a URL string
        const aspect = tex.image.width / tex.image.height;
        const baseHeight = 12;
        const baseWidth = baseHeight * aspect;
        node.__sprite.scale.set(baseWidth, baseHeight, 1);
        node.__baseScale = { w: baseWidth, h: baseHeight };
      });

      const mat = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(mat);
      node.__sprite = sprite;
      return sprite;
    })
    .onNodeHover(node => {
      // ... (original hover logic remains unchanged) ...
      if (hoveredNode && hoveredNode.__sprite && hoveredNode.__baseScale) {
        hoveredNode.__sprite.scale.set(hoveredNode.__baseScale.w, hoveredNode.__baseScale.h, 1);
      }
      if (node && node.__sprite && node.__baseScale) {
        const scaleFactor = 8;
        node.__sprite.scale.set(node.__baseScale.w * scaleFactor, node.__baseScale.h * scaleFactor, 1);
      }
      hoveredNode = node || null;
      document.body.style.cursor = node ? 'pointer' : '';
    });

  // 2. get data from backend API
  async function fetchGraphData() {
    try {
      // assume the backend API endpoint is 'https://your-api-endpoint.com/api/graph-data'
      const response = await fetch('https://your-api-endpoint.com/api/graph-data');
      const data = await response.json();

      // 3. update Graph data
      Graph.graphData(data);

    } catch (error) {
      console.error("無法獲取數據:", error);
    }
  }

  // 4. execute data fetching
  fetchGraphData();

  // 5. (optional) If you want "Real-time" updates as the poster suggests, you can set up periodic refresh
  // Fetch new data from the backend every 5 seconds
  setInterval(fetchGraphData, 5000);
  </script>
</body>


</html>